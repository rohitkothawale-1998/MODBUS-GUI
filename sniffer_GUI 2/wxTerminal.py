#!/usr/bin/env python
# generated by wxGlade 0.3.1 on Fri Oct 03 23:23:45 2003

#from wxPython.wx import *
import wx
import wxSerialConfigDialog
import serial
import threading
from base import XBeeBase
from struct import *
from datetime import *
import json
import time
import struct
imageInfo_format= '<10sHHI34sI8s'

def imageInfo(filename):
    input = open(filename, 'rb')
    record = input.read(struct.calcsize(imageInfo_format))
    if record == b'':
        input.close()
    result_list = struct.unpack(imageInfo_format, record)
    return result_list

def peek(offset, maxsize, filename): #this is just for now, will need to keep input open in real use!
    filesize = (imageInfo(filename))[5]
    ####print("Look for offset at", offset, " of ", filesize, " with maxsize", maxsize)
    input = open(filename, 'rb')
    input.read(offset)
    if (offset+maxsize) < filesize: 
        record = input.read(maxsize)
    else: #not enough in the file, we will fix the file size query too.
        record = input.read(filesize-offset)
    input.close()
    return record

def inspect(s):
    hex_chars = list(map(hex, map(ord, s)))
    counter = 0
    print(hex_chars)
    for c in hex_chars:
        print("{ ", counter, ", ", c, " }")
        counter+=1

ndp_deviceType =''
ndp_deviceUptime = ''
ndp_deviceIEEEAddr = ''
ndp_packetLoss = ''
ndp_retryCounter = ''
ndp_shortAddress = ''
ndp_workingMemory = ''
ndp_parentIEEEaddr = ''
ndp_deviceRssi = ''

fileCounter = 0
testCondition = 0

deviceMatrix = [{'deviceType':'0', 'deviceUptime':'0','ieee_address':'00c0b700008c83a7', 'packetLoss':'0','retryCounter':'0', 'shortAddress':'0000','workingMemory':'0'}]

deviceLinks = []

networkJson = {'links':deviceLinks, 'nodes':deviceMatrix}

#----------------------------------------------------------------------
# This function will take a the new information from an NDP
# Update the current data structure with new information or add a new node.
#
#

def addNewNodeInformation(deviceType, deviceUptime,ieee_address, packetLoss,retryCounter, shortAddress,workingMemory, parentIEEE, linkRssi):
    newDeviceNode = {'deviceType':deviceType, 'deviceUptime':deviceUptime,'ieee_address':ieee_address, 'packetLoss':packetLoss,'retryCounter':retryCounter, 'shortAddress':shortAddress,'workingMemory':workingMemory}

    index = 0
    indexInQuestion = -1
    for k in deviceMatrix:
        if k['ieee_address'] == ieee_address:
            indexInQuestion = index
            break
        index = index + 1

    if indexInQuestion >= 0:
        del deviceMatrix[indexInQuestion]
    deviceMatrix.append(newDeviceNode)


    newLink = {'ieee_address':ieee_address,'parent_ieee_address':parentIEEE,'rssi':linkRssi}
    Index2 = 0
    indexInQuestion2 = -1
    for j in deviceLinks:
        if j['ieee_address'] == ieee_address:
            indexInQuestion2 = Index2
            break
        Index2 = Index2 + 1

    if indexInQuestion2 >= 0:
        del deviceLinks[indexInQuestion2]

    deviceLinks.append(newLink)


    ##make sure that link is to a valid node

    found = False
    for k in deviceMatrix:
        if k['ieee_address'] == parentIEEE:
            found = True
            break

    if found:
        pass
    else:
        print(30*'*'+'UNKNOWN LINK'+30*'*')
        print(newLink)
        newDeviceNode = {'deviceType':"3", 'deviceUptime':"0",'ieee_address':parentIEEE, 'packetLoss':"ffff",'retryCounter':"ffff", 'shortAddress':"ffff",'workingMemory':"ffff"}
        deviceMatrix.append(newDeviceNode)

#----------------------------------------------------------------------
# Create an own event type, so that GUI updates can be delegated
# this is required as on some platforms only the main thread can
# access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave
# could be used too, but an event is more elegant.

SERIALRX = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0)
def checksum(s):
    return pack('B', sum(unpack(str(str(len(s))+"B"), s))%256)

def format(d, tab=0):
    #s = ['{\n']
    s = ['']
    for k,v in d.items():
        if isinstance(v, dict):
            v = format(v, tab+1)
        else:
            if k=='transID':
                v = str(int(v.hex(), 16 ))
            if k=='controlBit':
                v = str(int(v.hex(), 16 ))
            elif k=='xA':
                v = v[::-1].hex()
            elif k=='SKU':
                v = v[::-1]
            elif k=='Serial':
                v = v[::-1]
            elif k=='Reboot_Reason':
                v = repr(v)
            elif k=='SDP_version':
                v = v.hex()
            elif k=='Mfg_date':
                v = v[::-1].hex()
            elif k=='UTC_Time':
                v = v[::-1].hex()
            elif k=='Reserved_Data':
                v = v.hex()
            elif k=='Channel_ID':
                v = str(int(v.hex(), 16 ))
            #elif k=='Device_type':
            #    v = v.hex()
            elif k=='rssi':
                v = int(v.hex(), 16) - 255
            elif k=='int_temp':
                v = int(v[::-1].hex(), 16)
            elif k=='int_humid':
                v = int(v[::-1].hex(), 16)
            elif k=='battery':
                v = int(v[::-1].hex(), 16)
            elif k=='FW_version':
                v = v[::-1].hex()
            elif k=='HW_version':
                v = v[::-1].hex()
            elif k=='Port1':
                v = v[::-1].hex()
            elif k=='Port2':
                v = v[::-1].hex()
            elif k=='Port3':
                v = v[::-1].hex()
            elif k=='Port1_Reading':
                v = v[::-1].hex()
            elif k=='Port2_Reading':
                v = v[::-1].hex()
            elif k=='Port3_Reading':
                v = v[::-1].hex()
            elif k=='PANID':
                v = v[::-1].hex()
            elif k=='Security_key':
                v = v.hex()
            elif k=='deviceUpTime':
                v = int(v[::-1].hex(), 16)
            elif k=='ieee_address':
                v = v[::-1].hex()
                ndp_deviceIEEEAddr = v
            elif k=='parent_ieee_address':
                v = v[::-1].hex()
                ndp_parentIEEEaddr = v
            elif ((k=='deviceType') or (k=='Device_type')):
                v = int(v.hex(), 16)
                if v == 0:
                    v = "Coordinator"
                elif v == 1:
                    v = "Router"
                elif v == 2:
                    v = "End Device"
                elif v == 3:
                    v = "RDNT PC"
                elif v == 4:
                    v = "RDNT SC"
                elif v == 5:
                    v = "RDNT End Device"
                else:
                    v = "End Device"
                ndp_deviceType = v
            elif k=='workingMemory':
                v = int(v[::-1].hex(), 16)
                ndp_workingMemory = v
            elif k=='packetLoss':
                v = int(v[::-1].hex(), 16)
                ndp_packetLoss = v
            elif k=='retryCount':
                v = int(v[::-1].hex(), 16)
                ndp_retryCounter = v
            elif k=='parent_sA':
                v = "0x"+v[::-1].hex()
            elif k=='sA':
                v = "0x"+v[::-1].hex()
                ndp_shortAddress = v
            else: # this is the default function
                v = repr(v)
        #s.append('%s%r: %s,\n' % ('  '*tab, k, v)) #itemilze all fields, good for debug
        s.append('%s:' % (v)) #simplified display and debug info
    #s.append('%s}' % ('  '*tab))
    return ''.join(s)

class SerialRxEvent(wx.PyCommandEvent):
    eventType = SERIALRX
    def __init__(self, windowID, data):
        wx.PyCommandEvent.__init__(self, self.eventType, windowID)
        self.data = data

    def Clone(self):
        self.__class__(self.GetId(), self.data)

#----------------------------------------------------------------------

ID_CLEAR        = wx.NewId()
ID_SAVEAS       = wx.NewId()
ID_SETTINGS     = wx.NewId()
ID_TERM         = wx.NewId()
ID_EXIT         = wx.NewId()
ID_SEND_HOTSHOT	= wx.NewId()
ID_SEND_STATUSREQ= wx.NewId()
ID_SEND_SJOIN_ACCEPT= wx.NewId()
ID_SEND_TIME_RESP = wx.NewId()
ID_SEND_QNP_RESP = wx.NewId()
ID_SEND_PE_RESP = wx.NewId()
ID_SEND_RMT_CMD = wx.NewId()
ID_SEND_REMNODE_CMD = wx.NewId()
ID_SEND_COLDSHOT = wx.NewId()
ID_SEND_RDNTHOTSHOT = wx.NewId()
ID_SEND_RDNTCOLDSHOT = wx.NewId()
ID_SEND_PKGNOTIFY_USB = wx.NewId()
ID_SEND_PKGNOTIFY_MINI = wx.NewId()
ID_SEND_PKGNOTIFY_SP180 = wx.NewId()

NEWLINE_CR      = 0
NEWLINE_LF      = 1
NEWLINE_CRLF    = 2

class TerminalSetup:
    """Placeholder for various terminal settings. Used to pass the
       options to the TerminalSettingsDialog."""
    def __init__(self):
        self.echo = False
        self.unprintable = False
        self.newline = NEWLINE_CRLF

class TerminalSettingsDialog(wx.Dialog):
    """Simple dialog with common terminal settings like echo, newline mode."""

    def __init__(self, *args, **kwds):
        self.settings = kwds['settings']
        del kwds['settings']
        # begin wxGlade: TerminalSettingsDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.checkbox_echo = wx.CheckBox(self, -1, "Local Echo")
        self.checkbox_unprintable = wx.CheckBox(self, -1, "Show unprintable characters")
        self.radio_box_newline = wx.RadioBox(self, -1, "Newline Handling", choices=["CR only", "LF only", "CR+LF"], majorDimension=0, style=wx.RA_SPECIFY_ROWS)
        self.button_ok = wx.Button(self, -1, "OK")
        self.button_cancel = wx.Button(self, -1, "Cancel")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.__attach_events()
        self.checkbox_echo.SetValue(self.settings.echo)
        self.checkbox_unprintable.SetValue(self.settings.unprintable)
        self.radio_box_newline.SetSelection(self.settings.newline)

    def __set_properties(self):
        # begin wxGlade: TerminalSettingsDialog.__set_properties
        self.SetTitle("Terminal Settings")
        self.radio_box_newline.SetSelection(0)
        self.button_ok.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalSettingsDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_4 = wx.StaticBoxSizer(wx.StaticBox(self, -1, "Input/Output"), wx.VERTICAL)
        sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4)
        sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4)
        sizer_4.Add(self.radio_box_newline, 0, 0, 0)
        sizer_2.Add(sizer_4, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL|wx.ALIGN_RIGHT, 4)
        self.SetAutoLayout(1)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        sizer_2.SetSizeHints(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        self.Bind(wx.EVT_BUTTON, self.OnOK, id = self.button_ok.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnCancel, id = self.button_cancel.GetId())

    def OnOK(self, events):
        """Update data wil new values and close dialog."""
        self.settings.echo = self.checkbox_echo.GetValue()
        self.settings.unprintable = self.checkbox_unprintable.GetValue()
        self.settings.newline = self.radio_box_newline.GetSelection()
        self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        """Do not update data but close dialog."""
        self.EndModal(wx.ID_CANCEL)

# end of class TerminalSettingsDialog


class TerminalFrame(wx.Frame):
    """Simple terminal program for wxPython"""

    def __init__(self, *args, **kwds):
        self.XAddr = ''
        self.serial = serial.Serial()
        self.serial.timeout = 0.5   #make sure that the alive event can be checked from time to time
        self.settings = TerminalSetup() #placeholder for the settings
        self.thread = None
        self.alive = threading.Event()
        # begin wxGlade: TerminalFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.text_ctrl_output = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE|wx.TE_READONLY)

        # Menu Bar
        self.frame_terminal_menubar = wx.MenuBar()
        self.SetMenuBar(self.frame_terminal_menubar)
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_CLEAR, "&Clear", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(ID_SAVEAS, "&Save Text As...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_SETTINGS, "&Port Settings...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(ID_TERM, "&Terminal Settings...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_EXIT, "&Exit", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "&File")
        # Menu Bar end

    #Tim's new send packet item
        wxglade_send_menu = wx.Menu()
        wxglade_send_menu.Append(ID_SEND_HOTSHOT, "&Send HotShot", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_STATUSREQ, "&Send Status Request", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_SJOIN_ACCEPT, "&Send SJoin Accept", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_TIME_RESP, "&Send Time Request Resp", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_QNP_RESP, "&Send QNP Resp", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_PE_RESP, "&Send PE Resp", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_RMT_CMD, "&Send Remote Command", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_REMNODE_CMD, "&Send Remove Node Command", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_COLDSHOT, "&Send ColdShot", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_RDNTHOTSHOT, "&Send RDNT HotShot", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_RDNTCOLDSHOT, "&Send RDNT ColdShot", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_PKGNOTIFY_USB, "&Send 1104 PKGNOTIFY", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_PKGNOTIFY_MINI, "&Send 1102 PKGNOTIFY", "", wx.ITEM_NORMAL)
        wxglade_send_menu.Append(ID_SEND_PKGNOTIFY_SP180, "&Send 1101 PKGNOTIFY", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_send_menu, "&Send")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.__attach_events()          #register events
        self.OnPortSettings(None)       #call setup dialog on startup, opens port
        if not self.alive.isSet():
            self.Close()
        
        # Try to initialize XBee interpreter if the port is open
        try:
            if self.serial.is_open:
                self.Argus = XBeeBase(self.serial)
            else:
                self.Argus = None
        except Exception as e:
            print("Failed to initialize XBee:", e)
            self.Argus = None

    def StartThread(self):
        """Start the receiver thread"""
        self.thread = threading.Thread(target=self.ComPortArgusThread)
        self.thread.setDaemon(1)
        self.alive.set()
        self.thread.start()

    def StopThread(self):
        """Stop the receiver thread, wait util it's finished."""
        if self.thread is not None:
            self.alive.clear()          #clear alive event for thread
            self.thread.join()          #wait until thread has finished
            self.thread = None

    def __set_properties(self):
        # begin wxGlade: TerminalFrame.__set_properties
        self.SetTitle("Serial Terminal")
        self.SetSize((546, 383))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0)
        self.SetAutoLayout(1)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        #register events at the controls
        self.Bind(wx.EVT_MENU, self.OnClear, id = ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id = ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnExit, id = ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id = ID_SETTINGS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id = ID_TERM)
        self.Bind(wx.EVT_MENU, self.OnSendHotShot, id = ID_SEND_HOTSHOT)
        self.Bind(wx.EVT_MENU, self.OnSendStatusReq, id = ID_SEND_STATUSREQ)
        self.Bind(wx.EVT_MENU, self.OnSendSJoinAccept, id = ID_SEND_SJOIN_ACCEPT)
        self.Bind(wx.EVT_MENU, self.OnSendTimeResponse, id = ID_SEND_TIME_RESP)
        self.Bind(wx.EVT_MENU, self.OnSendQNPResponse, id = ID_SEND_QNP_RESP)
        self.Bind(wx.EVT_MENU, self.OnSendPEResponse, id = ID_SEND_PE_RESP)
        self.Bind(wx.EVT_MENU, self.OnSendRMTCommand, id = ID_SEND_RMT_CMD)
        self.Bind(wx.EVT_MENU, self.OnSendRemoveNode, id = ID_SEND_REMNODE_CMD)
        self.Bind(wx.EVT_MENU, self.OnSendColdShot, id = ID_SEND_COLDSHOT)
        self.Bind(wx.EVT_MENU, self.OnSendRDNTHotShot, id = ID_SEND_RDNTHOTSHOT)
        self.Bind(wx.EVT_MENU, self.OnSendRDNTColdShot, id = ID_SEND_RDNTCOLDSHOT)
        self.Bind(wx.EVT_MENU, self.OnSendPKGNotify_USB, id = ID_SEND_PKGNOTIFY_USB)
        self.Bind(wx.EVT_MENU, self.OnSendPKGNotify_MINI, id = ID_SEND_PKGNOTIFY_MINI)
        self.Bind(wx.EVT_MENU, self.OnSendPKGNotify_SP180, id = ID_SEND_PKGNOTIFY_SP180)
        self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey)
        self.Bind(EVT_SERIALRX, self.OnSerialRead)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnExit(self, event):
        """Menu point Exit"""
        self.Close()

    def OnClose(self, event):
        """Called on application shutdown."""
        self.StopThread()               #stop reader thread
        self.serial.close()             #cleanup
        self.Destroy()                  #close windows, exit app

    def OnSaveAs(self, event):
        """Save contents of output window."""
        filename = None
        dlg = wx.FileDialog(None, "Save Text As...", ".", "", "Text File|*.txt|All Files|*",  wx.SAVE)
        if dlg.ShowModal() ==  wx.ID_OK:
            filename = dlg.GetPath()
        dlg.Destroy()

        if filename is not None:
            f = open(filename, 'w')
            text = self.text_ctrl_output.GetValue()
            if type(text) == str:
                text = text.encode("latin1")    #hm, is that a good asumption?
            f.write(text.decode('latin1') if isinstance(text, bytes) else text)
            f.close()

    def OnClear(self, event):
        """Clear contents of output window."""
        self.text_ctrl_output.Clear()

    def OnSendHotShot(self, event):
        #HotShot = (0xFE, 0x01, 0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x04, 0x03)
        HotShot = b"\xFE\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x03"
        self.serial.write(HotShot)
        self.text_ctrl_output.AppendText("\n ====> Hot Shot \n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendStatusReq(self, event):
        StatusReq = b"\xFE\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x01"
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Status Request\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendSJoinAccept(self, event):
        #StatusReq = "\xFE\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x19\x01\x1f\xcd\x2e\x02\x00\xb7\xc0\x00\xb6"
        StatusReq = b"\xFE"
        StatusReq += b"\x0a" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00"
        StatusReq += b"\x19" #command ID
        StatusReq += b"\x01" #Join granted, 0x00 reject
        #StatusReq += "\xa4\x83\x8c\x00\x00\xb7\xc0\x00"
        #now we need to get the IEEE mac from the request and send it back.
        StatusReq += self.XAddr
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> SJoin Granted\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendTimeResponse(self, event):
        #StatusReq = "\xFE\x05\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x1f\x1a\x91\x2f\x67\x64"
        StatusReq = b"\xFE"
        StatusReq += b"\x05" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00"
        StatusReq += b"\x1f" #command ID
        StatusReq += b"\x1a\x91\x2f\x67"
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Time Request Responded\n")
        self.text_ctrl_output.AppendText(event.data)
        self.text_ctrl_output.AppendText("\n")

    def OnSendPEResponse(self, event):
        StatusReq = b"\xFE\x12\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x1d\x04\xf4\xc4\x04\x11\x01\x00\x01\x00\x1a\xc3\x4a\xbb\xff\xff\xff\xff"
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Package End Request Responded\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendRMTCommand(self, event):
        #StatusReq = "\xFE\x0D\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x20\xbf\xce\x2e\x02\x00\x4b\x12\x00"
        StatusReq = b"\xFE\x0D\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x20\x0e\xcd\x2e\x02\x00\x4b\x12\x00"
        StatusReq += b"\x05\x68\x65\x6c\x70\x0D" #this is the body of remote cmmand, length + contents
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> OTA Remote Command Issued\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendRemoveNode(self, event):
        StatusReq = b"\xFE\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x04\x01" #0x01 means we need ACK back.
        #StatusReq += b"\x23\x00\x27\x74\x02\x00\x4b\x12\x00" #here's the body of the command
        #StatusReq += b"\x23\x03\x63\x46\x01\x00\x4b\x12\x00" #here's the body of the command
        #StatusReq += b"\x23\xdd\x62\x46\x01\x00\x4b\x12\x00" #here's the body of the command
        #StatusReq += b"\x23\xa4\x83\x8c\x00\x00\xb7\xc0\x00" #here's the body of the command
        StatusReq += b"\x23\x00\xee\x26\x74\x02\x00\x4b\x12\x00" #here's the body of the command
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Remove Node Command Issued\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendColdShot(self, event):
        StatusReq = b"\xFE\x01\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x14"
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Send Cold Shot\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendRDNTHotShot(self, event):
        StatusReq = b"\xFE\x01\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28"
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Send RDNT Hot Shot\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendRDNTColdShot(self, event):
        StatusReq = b"\xFE\x01\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x29"
        StatusReq += checksum(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Send RDNT Cold Shot\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendPKGNotify_USB(self, event):
        StatusReq = b"\xFE"
        StatusReq += b"\x05" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00" #long and control 
        StatusReq += b"\x0a" #command body
        #StatusReq += struct.pack('BB', 04, 11) # PKGTAPE
        StatusReq += b"\xf4\xc4" # Man ID
        StatusReq += b"\x04\x11" # PKGTAPE
        StatusReq += checksum(StatusReq)
        inspect(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Send USB Dongle PKG Notify\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendPKGNotify_MINI(self, event):
        StatusReq = b"\xFE"
        StatusReq += b"\x05" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00" #long and control 
        StatusReq += b"\x0a" #command body
        StatusReq += b"\xf4\xc4" # Man ID
        StatusReq += b"\x02\x11" # PKGTAPE
        StatusReq += checksum(StatusReq)
        inspect(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Send MINI PKG Notify\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendPKGNotify_SP180(self, event):
        StatusReq = b"\xFE"
        StatusReq += b"\x05" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00" #long and control 
        StatusReq += b"\x0a" #command body
        StatusReq += b"\xf4\xc4" # Man ID
        StatusReq += b"\x01\x11" # PKGTAPE
        StatusReq += checksum(StatusReq)
        inspect(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> Send SP180 PKG Notify\n")
        self.text_ctrl_output.AppendText("\n")

    def OnSendQNPResponse(self, event, type):
        #StatusReq = "\xFE\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x1b\x01\xf4\xc4\x04\x11\x01\x00\x01\x00\x5c\xea\x02\x00"
        StatusReq = b"\xFE"
        StatusReq += b"\x0e" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00"
        StatusReq += b"\x1b" #command ID
        StatusReq += b"\x01" #control bits: 01 - get a file, 00 - no file.
        if (type == b"\x04\x11"):
            result_list = imageInfo("C4F4-1104-00010033-NBWC100UAPP.zigbee")
        elif (type == b"\x02\x11"):
            result_list = imageInfo("C4F4-1102-00010022-NBWS100App.zigbee")
        elif (type == b"\x01\x11"):
            result_list = imageInfo("C4F4-1101-00010052-NBPD0180APP.zigbee")
        else:
            print("Type is wrong: ====>", type)
            exit()

        #StatusReq += "\xf4\xc4" #man ID
        StatusReq += struct.pack('<H', result_list[1]) #man ID
        #StatusReq += "\x04\x11" #package ID
        StatusReq += struct.pack('<H', result_list[2]) #package ID
        #StatusReq += "\x37\x23\x01\x00" #file version
        StatusReq += struct.pack('<I', result_list[3]) #file version
        #StatusReq += "\x08\xfc\x02\x00" #file length
        StatusReq += struct.pack('<I', result_list[5]) #file size 

        StatusReq += checksum(StatusReq)
        inspect(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> QNP Request Responsed\n")
        self.text_ctrl_output.AppendText("\n")
        self.text_ctrl_output.AppendText(str(StatusReq))
        self.text_ctrl_output.AppendText("\n")

    def OnSendPKGBlockResponse(self, event, type, offset, maxsize, version):
        
        StatusReq = b"\xFE"
        StatusReq += b"\x0f" #command length
        StatusReq += b"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00"
        StatusReq += b"\x1c" #command ID
        StatusReq += b"\x01" #control bits: 01 - get a file, 00 - no file.
        StatusReq += b"\xf4\xc4" #man ID
        #StatusReq += "\x04\x11" #package ID
        StatusReq += type 
        StatusReq += version #file version
        StatusReq += offset #file offset 
        #StatusReq += pack('>I', offset) #file offset 
        #StatusReq += "\x52" #the transport size FIX IT!
        #StatusReq += pack('B',maxsize)
        StatusReq += maxsize
        if (type == b'\x04\x11'):
            filename = "C4F4-1104-00010033-NBWC100UAPP.zigbee"
        elif (type == b'\x02\x11'):
            filename = "C4F4-1102-00010022-NBWS100App.zigbee"
        elif (type == b'\x01\x11'):
            filename = "C4F4-1101-00010052-NBPD0180APP.zigbee"
        else:
            print("Type is wrong: ====>", type)
        StatusReq += peek(int(offset.hex(), 16), int(maxsize.hex(), 16), filename) #file offset and maxsize will need to be filled in from request side.
        StatusReq += checksum(StatusReq)
        
        inspect(StatusReq)
        self.serial.write(StatusReq)
        self.text_ctrl_output.AppendText("\n ====> PKG Block Request Responsed\n")
        self.text_ctrl_output.AppendText("\n")
        self.text_ctrl_output.AppendText(str(StatusReq))
        self.text_ctrl_output.AppendText("\n")
        if testCondition > 3:
            exit()
        testCondition+=1

    def OnPortSettings(self, event=None):
        """Show the portsettings dialog. The reader thread is stopped for the
           settings change."""
        if event is not None:           #will be none when called on startup
            self.StopThread()
            self.serial.close()
        ok = False
        while not ok:
            dialog_serial_cfg = wxSerialConfigDialog.SerialConfigDialog(None, -1, "",
                show=wxSerialConfigDialog.SHOW_BAUDRATE|wxSerialConfigDialog.SHOW_FORMAT|wxSerialConfigDialog.SHOW_FLOW,
                serial=self.serial
            )
            result = dialog_serial_cfg.ShowModal()
            dialog_serial_cfg.Destroy()
            #open port if not called on startup, open it on startup and OK too
            if result == wx.ID_OK or event is not None:
                try:
                    self.serial.open()
                except serial.SerialException as e:
                    dlg = wx.MessageDialog(None, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)
                    dlg.ShowModal()
                    dlg.Destroy()
                else:
                    self.StartThread()
                    self.SetTitle("Serial Terminal on %s [%s, %s%s%s%s%s]" % (
                        self.serial.portstr,
                        self.serial.baudrate,
                        self.serial.bytesize,
                        self.serial.parity,
                        self.serial.stopbits,
                        self.serial.rtscts and ' RTS/CTS' or '',
                        self.serial.xonxoff and ' Xon/Xoff' or '',
                        )
                    )
                    ok = True
            else:
                #on startup, dialog aborted
                self.alive.clear()
                ok = True

    def OnTermSettings(self, event):
        """Menu point Terminal Settings. Show the settings dialog
           with the current terminal settings"""
        dialog = TerminalSettingsDialog(None, -1, "", settings=self.settings)
        result = dialog.ShowModal()
        dialog.Destroy()

    def OnKey(self, event):
        """Key event handler. if the key is in the ASCII range, write it to the serial port.
           Newline handling and local echo is also done here."""
        code = event.GetKeyCode()
        if code < 256:                          #is it printable?
            if code == 13:                      #is it a newline? (check for CR which is the RETURN key)
                if self.settings.echo:          #do echo if needed
                    self.text_ctrl_output.AppendText('\n')
                if self.settings.newline == NEWLINE_CR:
                    self.serial.write(b'\r')     #send CR
                elif self.settings.newline == NEWLINE_LF:
                    self.serial.write(b'\n')     #send LF
                elif self.settings.newline == NEWLINE_CRLF:
                    self.serial.write(b'\r\n')   #send CR+LF
            else:
                char = chr(code)
                if self.settings.echo:          #do echo if needed
                    self.text_ctrl_output.WriteText(char)
                self.serial.write(char.encode('utf-8'))         #send the charcater
        else:
            print("Extra Key:", code)

    def OnSerialRead(self, event):
        global fileCounter
        """Handle input from the serial port."""
        id = event.data['id']
        print(format(event.data))
        text = str(event.data)
        text = format(event.data)
        if self.settings.unprintable:
            text = ''.join([(c >= ' ') and c or '<%d>' % ord(c)  for c in text])
        if id == 'PANID':
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'STATUS':
            if event.data['Reboot_Reason'] == '"':
                event.data['Reboot_Reason'] = "OFF"
            elif event.data['Reboot_Reason'] == '!':
                event.data['Reboot_Reason'] = "ON"
            elif event.data['Reboot_Reason'] == '#':
                event.data['Reboot_Reason'] = "Operation Failed"
            text = format(event.data)
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'SJOIN_REQ':
            #self.text_ctrl_output.AppendText(str(int(event.data['XAddr'].hex(), 16)))
            self.XAddr = event.data['XAddr']
            #text = format(event.data)	
	    #if (self.XAddr == event.data['xA']):
            self.OnSendSJoinAccept(id)
            text += "SEND SJOIN ACCEPT"
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'Query_Next_Package_REQ':
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
            type = event.data['PKGTYPE']
            self.OnSendQNPResponse(id, type)
            text = "SEND QNP Response"
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'Package_Block_REQ':
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("\r\n")
            type = event.data['PKGTYPE'] #just this part. 
            offset = event.data['OFFSET']
            maxsize = event.data['MAX_BLOCK_SIZE']
            version = event.data['FILEVER']
            self.OnSendPKGBlockResponse(id, type, offset, maxsize, version)
            text = "SEND PKG Block Response"
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'Package_End_REQ':
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'TIME_REQ':
            self.OnSendTimeResponse(id)
            text = "SEND TIME_REQ Response"
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'SDP':
            s = str(datetime.now())
            self.text_ctrl_output.AppendText(s)
            self.text_ctrl_output.AppendText("----")
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("----")
            self.text_ctrl_output.AppendText(str(int(event.data['transID'].hex(), 16)))
            self.text_ctrl_output.AppendText("----   ")
            self.text_ctrl_output.AppendText(str("%1.1f" % (3.45*int(event.data['battery'][::-1].hex(), 16)/2047)))
            self.text_ctrl_output.AppendText(" Volt")
            self.text_ctrl_output.AppendText("---    ")
            self.text_ctrl_output.AppendText(str(int(event.data['rssi'].hex(), 16) - 255))
            self.text_ctrl_output.AppendText(" db")
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")
        elif id == 'NDP':
            s = str(datetime.now())

            self.text_ctrl_output.AppendText(s)
            self.text_ctrl_output.AppendText("----")
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("----")
            self.text_ctrl_output.AppendText(str(int(event.data['transID'].hex(), 16)))
            self.text_ctrl_output.AppendText("----   ")
            self.text_ctrl_output.AppendText(str(int(event.data['rxLQI'].hex(), 16) - 255))
            self.text_ctrl_output.AppendText(" db")
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")

        else:
            self.text_ctrl_output.AppendText(id)
            self.text_ctrl_output.AppendText("\r\n")
            self.text_ctrl_output.AppendText(text)
            self.text_ctrl_output.AppendText("\r\n")

    def ComPortArgusThread(self):
        # thread that will handle the serial traffic using xbee intrepreter.
        while self.alive.isSet():
            try:
                if self.Argus is not None:
                    print("start XBee interpreter")
                    text = self.Argus.wait_read_frame()
                    print(text)
                    event = SerialRxEvent(self.GetId(), text)
                    self.GetEventHandler().AddPendingEvent(event)
                else:
                    # If XBee is not initialized, just sleep a bit
                    time.sleep(0.5)
            except KeyboardInterrupt:
                break
            except Exception as e:
                print("Error in XBee interpreter:", e)
                time.sleep(0.5)

    def ComPortThread(self):
        """Thread that handles the incomming traffic. Does the basic input
           transformation (newlines) and generates an SerialRxEvent"""
        while self.alive.isSet():               #loop while alive event is true
            text = self.serial.read(1)          #read one, with timout
            if text:                            #check if not timeout
                n = self.serial.inWaiting()     #look if there is more to read
                if n:
                    text = text + self.serial.read(n) #get it
                #newline transformation
                if self.settings.newline == NEWLINE_CR:
                    text = text.replace(b'\r', b'\n')
                elif self.settings.newline == NEWLINE_LF:
                    pass
                elif self.settings.newline == NEWLINE_CRLF:
                    text = text.replace(b'\r\n', b'\n')
                event = SerialRxEvent(self.GetId(), text)
                self.GetEventHandler().AddPendingEvent(event)
                #~ self.OnSerialRead(text)         #output text in window

# end of class TerminalFrame


class MyApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_terminal = TerminalFrame(None, -1, "")
        self.SetTopWindow(frame_terminal)
        frame_terminal.Show(1)
        return 1

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
